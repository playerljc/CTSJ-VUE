# Vue模拟实现(一)


#  目录
- [概述](#概述)
- [所用的知识点](#所用的知识点)
- [模拟的内容](#模拟的内容)
- [没有模拟的内容](#没有模拟的内容)
- [关键技术点和相关术语](#关键技术点和相关术语)
- [整体流程和思路](#整体流程和思路)

## 概述
&ensp;&ensp;如今，前端技术日新月异，发展速度之迅猛，各种各样的库层出不穷，起初从DoJo、jQuery、requirejs、jQueryUI、jQueryEasyUI、EXTJS等前端库风靡一时，在html，js和css技术的生态体系下，前端的开发模式从jsp、php和asp的服务器端渲染发展到了web2.0的ajax，前后端分离的开发模式也应运而生，从此前端和后端的职责越来越清晰，前端之前大部分都是操作DOM，jQuery库也成为了当时事实的标准库，围绕jQeury库的生态体系也是越来越强大，当时的js库大部分都是基于jQuery开发的，比较著名的jQueryUI、jQueryEasyUI和BootStrap也是开发项目的首选库，当时前端的构建也是基于一些exe工具，或者说有的工程都没有进行压缩合并的操作，随着nodejs技术的兴起，前端开发者也能去开发服务端，但是效果并不是很好，和javaweb比起来，nodejs还是没有找到自己的位置，各个方面都处于下风，可以说想撼动java的地位是不可能的，所以nodejs把重点放到了中间件和前端工程化上，当时比较成功的前端工程化库就是Grunt和gulp，也成为了当时前端工程化必不可少的2个选择，再谈一谈当时前端的模板技术，当时前端的模板技术都是单方向的模板技术都是基于指定表达式替换，如jsp的<%%>和freemark，struct1和struct2的标签库这个是web1.0中的模板库，web2.0总的模板库有jsrender，和underscores的template等，但是这些模板库都只是单方向的变量到字符串的形式，也就是我们常说的mv(模型到视图)，随着Backbone.js的出现mvvm的思想得以在浏览器端实现，但是Backbone.js没有大红大紫，原因是因为React的出现，React提出的概念就是mvvm和虚拟dom的概念，起初出现只有小部分公司在使用，之后大厂纷纷使用，同时React的生态环境也是越来越强大，Redux和React-Router，babel，在配合Webpack的全家桶的出现，使开发React更加便捷和可靠，这个以nodejs和es6作为工程化开发的模式孕育而生，可以说这种模式的出现，完全颠覆了前端的传统开发模式，很多前端都必须从原始的开发模式转到这种nodejs模式，在随着Vue的出现彻底把这种模式推向了一个至高点，也称成为了现在开发前端事实的标准模式，时代在改变，技术在发展，作为一个老的程序员来说，在接受新的事物的同时也要看清事物本质，只有看清本质才能利于不败之地，才能跟得上时代的发展，老话说的好，万变不离其宗，所以就有了想彻底弄清楚mvvm和虚拟dom本质的想法，所以想从react和vue这两个框架中选取一个进行模拟的编写来更加深入的d对mvvm进行了解，左思右想之后最终选择了Vue框架来进行模拟，原因是Vue的模板渲染更接近于Web的原始技术，数据的改变也更能让人理解，除了这点之外模拟编写这个库也能带来其他的收获，比如可以巩固和深入es和dom的相关知识，磨练自身的意志，最后这也是一个成需要的追求。

## 所用的知识点
 - ES6的Proxy
 - eval函数
 - with语句
 - Function构造函数
 - DOM相关操作
 - Object.definePropertys
 - es基础知识
 - Snabbdom(虚拟DOM)

## 模拟的内容
 - Vue实例
    - {{}}表达式的解析
    - v-bind
    - v-on
    - v-for
    - v-html
    - v-if
    - v-else
    - v-else-if
    - v-show
    - v-model
    - 生命周期
    - methods
    - computed
    - watch
 - 组件(Component)
    - 组件的注册(全局和局部)
    - props
    - slot(缺省和作用域)
 - template标签
 - component(动态组件)标签
 - ref和$refs
 - $root和$parent
 - $emit
 - mixin
 - vue-router的模拟
  - router-link
  - router-viewer
  - 路由解析
  - 导航方法
  - 路由守卫
 
## 没有模拟的内容
- filter
- 组件上使用v-model
- 方法的异步方法中多次修改data只渲染一次

## 关键技术点和相关术语
 - 模板解析技术
 - 数据观测(data observer)
 - 虚拟dom技术
 - 生命周期方法、methods和watch中多次修改数据，只执行一次渲染
 - 在proxy中如何判断数组的异动，是增、删和改的操作
 - v-for怎么解析
 - v-for或v-for嵌套中怎么创建新的作用域
 - 如果在指定作用域中执行字符串表达式
 - v-if、v-else-if和v-else怎么解析
 - 怎么能保留访问的路径字符串，可以在watch中使用
 - 组件怎么判断是挂载还是更新
 - props如何不能修改
 - 怎么实现组件注册中支持2种形式的注册
 - 怎么实现$emit的功能
 - 父亲更新，和组件自身更新，怎么渲染
 
## 整体流程和思路
&ensp;&ensp;首先是模拟的内容，按照从大到小分首先应该是Vue相关的模拟，其次是Vue-Router模拟，Vue相关的模拟中最为重点的应该是**Vue实例创建**、**模板的解析** 、**数据的观测**这几部分，模板的解析还可以分为**迭代**、**文本节点的表达式解析**、**指令的解析**、**组件节点的解析**、**Vue标签解析**，而数据响应式这块分为**Vue实例的数据响应式**，**组件的数据响应式**和**计算属性的处理**，整体流程可以用下图表示

![](https://github.com/playerljc/CTSJ-VUE/blob/integrate-demo/packages/ctsj-vue/docs/Vue模拟整体流程1.png)

&ensp;&ensp;上面的图展示了从一个div元素 -> 实例化Vue实例 -> 配置的解析一个完整的流程，这里面需要对2处详细说明，这两处也是最核心的2个地方，一个是数据响应式的建立，意外一个就是模板的解析，可以说模拟的核心就是这2处，如果完美的解决了这两块技术点，那么可以说我们就完成了百分之80%功能了，下面分别给出创建数据响应式和模板解析的关键流程。

下图是一个完成的模板解析流程：
![](https://github.com/playerljc/CTSJ-VUE/blob/integrate-demo/packages/ctsj-vue/docs/模板的解析.png)

&ensp;&ensp;模板解析的核心就是对template的html模板字符串进行解析，解析的方法定义为render，解析分为挂载和更新，不管是挂载还是更新，解析的核心就是对template的html字符串生成的游离dom结构进行迭代，在迭代当中在针对不同的节点情况进行分开解析，想了解具体的解析过程，我会在另一篇文章中详细讲述。

&ensp;&ensp;有了模板解析还不行，我们还要能够监听到数据的变化，下面就给出创建数据响应式的流程图。
![](https://github.com/playerljc/CTSJ-VUE/blob/integrate-demo/packages/ctsj-vue/docs/创建数据响应式.png)

&ensp;&ensp;创建数据响应式分为2种情况，一种是创建Vue实例数据的响应式，另一种是创建组件数据的响应式，创建数据响应式使用的核心技术是Proxy这个对象，Vue2用的是Object.defineProperty，用这种技术对数组的数据变化是监听不到的，而使用Proxy这种技术则可以对Object和Array的数据变化都可以监控到，首先对get和set2个钩子函数进行监听，在get种主要处理的是计算属性相关的操作，而在set里面需要对数据进行判断，只有Object和Array的数据变化我们才关系，其他的忽略，这里对Object和Array两种情况进行了分别的处理，数组数据的变化需要判断出，添加、修改和删除这三个操作，首先要处理的就是wacth监听这块，然后需要对改变的数据进行判断，如果是Object和Array类型则需要再次创建数据响应式，最后在实例化完Proxy对象之后，还需要对obj对象的每一个属性都需要建立数据响应式，因为我们需要监控到任意一级的数据变化，而不是只是数据的第一级数据变化，如果想了解更多细节，请阅读我分享的另一篇对数据监控这块的文章。

&ensp;&ensp;最后如果模板解析和数据监控都处理完了之后，我们的整体流程也就开发的差不多了，首先第一次的时候先调用一次render
