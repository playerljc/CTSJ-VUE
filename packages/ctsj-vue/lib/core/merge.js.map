{"version":3,"file":"merge.js","sources":["core/merge.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.mergeRouterHooks = exports.mergeMethods = exports.mergeComputed = exports.mergeData = exports.mergeProps = void 0;\r\nvar vue_util_1 = require(\"@ctsj/vue-util\");\r\n/**\r\n * mergeProps - 混入props到this中\r\n * @param props - Object 需要混入到this中的props对象\r\n */\r\nfunction mergeProps(props) {\r\n    var properties = {};\r\n    // 迭代props对象\r\n    Object.keys(props).forEach(function (key) {\r\n        properties[key] = {\r\n            value: props[key],\r\n            // 不能对props的属性进行赋值\r\n            writable: false,\r\n            // 可以删除\r\n            configurable: true,\r\n            // 可以枚举\r\n            enumerable: true,\r\n        };\r\n    });\r\n    // 混入就是为this定义props属性\r\n    Object.defineProperties(this, properties);\r\n}\r\nexports.mergeProps = mergeProps;\r\n/**\r\n * mergeData - 混入data到this中\r\n */\r\nfunction mergeData() {\r\n    vue_util_1.merge(this, vue_util_1.cloneDeep(vue_util_1.isFunction(this.$config.data) ? this.$config.data() : {}));\r\n}\r\nexports.mergeData = mergeData;\r\n/**\r\n * mergeComputed - 混入computed到this中\r\n */\r\nfunction mergeComputed() {\r\n    // 根据computed对象生成computedObj\r\n    var computed = this.$config.computed || {};\r\n    var computedObj = {};\r\n    // 只需要混入computed的key就可以，值暂为null，根据proxy的get生成值\r\n    for (var p in computed) {\r\n        computedObj[p] = null;\r\n    }\r\n    vue_util_1.merge(this, computedObj);\r\n}\r\nexports.mergeComputed = mergeComputed;\r\n/**\r\n * mergeMethods - 混入methods到this中\r\n */\r\nfunction mergeMethods() {\r\n    vue_util_1.merge(this, this.$config.methods || {});\r\n}\r\nexports.mergeMethods = mergeMethods;\r\n/**\r\n * mergeRouterHooks - 混入组件路由钩子\r\n *\r\n  beforeRouteEnter (to, from, next) {\r\n    // 在渲染该组件的对应路由被 confirm 前调用\r\n    // 不！能！获取组件实例 `this`\r\n    // 因为当守卫执行前，组件实例还没被创建\r\n  },\r\n  beforeRouteUpdate (to, from, next) {\r\n    // 在当前路由改变，但是该组件被复用时调用\r\n    // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，\r\n    // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。\r\n    // 可以访问组件实例 `this`\r\n  },\r\n  beforeRouteLeave (to, from, next) {\r\n    // 导航离开该组件的对应路由时调用\r\n    // 可以访问组件实例 `this`\r\n  }\r\n */\r\nfunction mergeRouterHooks() {\r\n    vue_util_1.merge(this, {\r\n        beforeRouteEnter: this.$config.beforeRouteEnter,\r\n        beforeRouteUpdate: this.$config.beforeRouteUpdate,\r\n        beforeRouteLeave: this.$config.beforeRouteLeave,\r\n    });\r\n}\r\nexports.mergeRouterHooks = mergeRouterHooks;\r\n"],"names":["Object","defineProperty","exports","value","mergeRouterHooks","mergeMethods","mergeComputed","mergeData","mergeProps","vue_util_1","require","props","properties","keys","forEach","key","writable","configurable","enumerable","defineProperties","this","merge","cloneDeep","isFunction","$config","data","p","computedObj","computed","methods","beforeRouteEnter","beforeRouteUpdate","beforeRouteLeave"],"mappings":"aACAA,OAAOC,eAAeC,QAAS,aAAc,CAAEC,OAAO,IACtDD,QAAQE,iBAAmBF,QAAQG,aAAeH,QAAQI,cAAgBJ,QAAQK,UAAYL,QAAQM,gBAAa,EACnH,IAAIC,WAAaC,QAAQ,kBAKzB,SAASF,WAAWG,GAChB,IAAIC,EAAa,GAEjBZ,OAAOa,KAAKF,GAAOG,QAAQ,SAAUC,GACjCH,EAAWG,GAAO,CACdZ,MAAOQ,EAAMI,GAEbC,UAAU,EAEVC,cAAc,EAEdC,YAAY,KAIpBlB,OAAOmB,iBAAiBC,KAAMR,GAMlC,SAASL,YACLE,WAAWY,MAAMD,KAAMX,WAAWa,UAAUb,WAAWc,WAAWH,KAAKI,QAAQC,MAAQL,KAAKI,QAAQC,OAAS,KAMjH,SAASnB,gBAEL,IAGSoB,EAFLC,EAAc,GAElB,IAASD,KAHMN,KAAKI,QAAQI,UAAY,GAIpCD,EAAYD,GAAK,KAErBjB,WAAWY,MAAMD,KAAMO,GAM3B,SAAStB,eACLI,WAAWY,MAAMD,KAAMA,KAAKI,QAAQK,SAAW,IAsBnD,SAASzB,mBACLK,WAAWY,MAAMD,KAAM,CACnBU,iBAAkBV,KAAKI,QAAQM,iBAC/BC,kBAAmBX,KAAKI,QAAQO,kBAChCC,iBAAkBZ,KAAKI,QAAQQ,mBApDvC9B,QAAQM,WAAaA,WAOrBN,QAAQK,UAAYA,UAcpBL,QAAQI,cAAgBA,cAOxBJ,QAAQG,aAAeA,aA2BvBH,QAAQE,iBAAmBA"}